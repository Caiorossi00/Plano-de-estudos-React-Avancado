Funções assíncronas em javascript são funções declaradas com a palavra-chave async e existem para tornar o trabalho com código assíncrono mais legível, previsível e próximo do modelo mental síncrono. Quando uma função é marcada como async, ela passa a retornar uma promise, independentemente de você retornar explicitamente uma promise ou um valor mais simples. Se um valor comum é retornado, o javascript o envolve automaticamente em uma promise resolvida, e se um erro é lançado dentro da função, isso equivale a uma promise rejeitada.

Dentro de uma função assíncrona, o operador await pode ser usado para pausar a execução daquela função até que uma promise seja resolvida ou rejeitada. Esse "pausar" não bloqueia a thread principal nem o event loop, ele apenas suspende a execução daquela função específica enquanto o restante do programa continua rodando normalmente. Quando a promise é resolvida, o valor resolvido é retornado pelo await, permitindo que o código seguinte use esse valor como se fosse o resultado de uma chamada síncrona.

O principal ganho das funções assíncronas está na clareza do fluxo. Antes do async/await, o encadeamento de promises exigia múltiplos then e catch, o que dificultava a leitura e a manutenção do código. Com funções assíncronas, o tratamento de erros pode ser feito com try/catch, que funciona de forma muito semelhante ao tratamento de exceções em código síncrono, tornando mais fácil entender onde os erros podem ocorrer e como eles são propagados.

É importante entender que funções assíncronas não criam paralelismo por si só. Elas apenas fornecem uma sintaxe mais simples para lidar com operações assíncronas que já dependem do event loop, como requisições HTTP, timers ou acessos a APIs externas. A execução continua sendo cooperativa e baseada em promises, e o uso de await influencia apenas a ordem de execução dentro da função, não o desempenho global do javascript em termos de múltiplas threads.

Na prática, funções assíncronas são hoje o padrão para lidar com código assíncrono em javascript moderno, especialmente em aplicações frontend e backend. Elas ajudam a escrever código mais linear, mais fácil de depurar e menos propenso a erros conceituais, desde que se tenha clareza de que async/await é uma abstração sobre promises, e não um novo modelo de execução. 
