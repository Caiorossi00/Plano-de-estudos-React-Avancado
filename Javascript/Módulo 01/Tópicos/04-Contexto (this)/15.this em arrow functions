Em arrow functions, o comportamento de this é propositalmente diferente das funções tradicionais. Arrow functions não possuem um this próprio. Em vez disso, elas capturam lexicalmente o valor de this do escopo onde foram definidas. Isso significa que o this dentro  de uma arrow function é exatamente o mesmo this do contexto externo no momento da criação da fundação, e não algo determinado na hora da execução.

Esse modelo elimina o comportamento dinâmico observado em funções tradicionais. Uma arrow function não altera seu this com base em como é chamada, nem quando é usada como método de objeto, callback ou passada como argumento. O valor de this permanece estável e previsível, pois está vinculado ao escopo léxico, não à forma de invocação.

Na prática, isso resolve uma classe comum de problemas do javascript. Callbacks que antes perdiam o contexto correto ao serem executados dentro de métodos ou funções assíncronas passam a acessar o this esperado automaticamente. Não é necessário usar variáveis intermediárias ou recorrer a bind para preservar o contexto, pois a arrow function já herda o this correto por definição.

Essa característica também impõe limitações. Arrow functions não devem ser usadas com métodos de objeto quando se espera que this represente o próprio objeto, nem como construtores, já que elas não possuem this, arguments nem o comportamento necessário para serem instanciadas com new. Elas são projetadas para funções pequenas, expressivas e fortemente ligadas ao contexto externo.

Em resumo, o this em arrow functions é estático e lexical, enquanto em funções tradicionais ele é dinâmico e dependente da chamada. Essa diferença é intencional e representa uma evolução do design da linguagem, oferecendo uma alternativa mais previsível para cenários em que o controle explícito de contexto é desejável.
