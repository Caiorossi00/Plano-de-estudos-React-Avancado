O hoisting (ou "içamento") é um comportamento do javascript onde as declarações de variáveis e funções são processadas pelo motor da linguagem antes mesmo de o código ser executado. Na prática, é como se o javascript "puxasse" essas declarações para o topo do seu escopo, permitindo que, em certos casos, você use uma função ou variável antes da linha onde ela foi escrita.

Imagine que você está lendo uma receita de bolo. No meio das instruções, aparece a frase "adicione a mistura que você preparou no passo 10". Mesmo que você ainda não tenha chegado fisicamente no passo 10, o seu cérebro já sabe que existe uma "mistura" mencionada ali na frente. No javascript, o motor de execução faz uma leitura rápida de todo o "papel" antes de começar a cozinhar, anotando o nome de todos os ingredientes e potes (variáveis e funções) que ele encontrou espalhados pelo texto, para que ele não se perca quando precisar usá-los. O hoisting é um comportamento automático e intrínseco do javascript, você não preisa fazer nada para que ele aconteça, ele faz parte da "natureza" da linguagem.

No javascript, hoisting é o comportamento pelo qual declarações são processadas antes da execução efetiva do código. Durante a fase inicial de execução, o runtime analisa o código e registra declarações de variáveis e funções nos seus respectivos escopos. Como consequência, identificadores podem existir no escopo antes mesmo de a linha onde foram declarados ser alcançada durante a execução, o que dá a impressão de que o javascript "move" declarações para o topo do código.

No caso das variáveis, o hoisting se manifesta de maneiras diferentes dependendo da forma de declaração. Variáveis declaradas com var têm seu identificador elevado para o topo do escopo de função ou global e são inicializadas automaticamente com o valor undefined. Isso permite que sejam acessadas antes da linha de declaração sem gerar erro, ainda que o valor não seja o esperado. Esse comportamento é uma das principais fontes de bugs em código antigo, pois mascara erros de ordem de execução e cria estados transitórios difíceis de detectar.

Já variáveis declaradas com let e const também passam pelo processo de hoisting, mas com uma diferença crucial. Embora o identificador seja registrado no escopo, ele não é inicializado imediatamente. Até que a execução alcance a linha de declaração, qualquer tentativa de acesso resulta em erro. Esse intervalo é conhecido como temporal dead zone. Esse mecanismo foi introduzido para impedir o uso prematuro de variáveis e tornar o código mais seguro e previsível, evitando comportamento silenciosos que antes passavam despercebidos.

O hoisting de funções segue regras distintas e mais consistentes. Funções declaradas por meio de function declarations são totalmente elevadas, incluindo sua definição. Isso significa que podem ser chamadas antes mesmo de aparecerem no código. Esse comportamento é intencional e facilita a organização lógica do programa, permitindo que funções de alto nível sejam utilizadas sem preocupação com a ordem textual das declarações.

Por outro lado, funções definidas como expressões, sejam elas atribuídas a variáveis com var, let ou const, seguem as regras de hoisting dessas variáveis. Nesse caso, apenas o identificador da variável é elevado, não a função em si. Como resultado, tentar invocar a função antes da atribuição resulta em erro ou em comportamento inesperado, dependendo do tipo de declaração utilizada. Essa diferença é fundamental para entender por que nem todas as funções se comportam da mesma forma em relação à ordem do código.

Os comportamentos inesperados associados ao hoisting não são falhas da linguagem, mas consequências diretas do seu modelo de execução. Quando esse modelo não é compreendido, o código pode parecer inconsistente ou imprevisível. Por esse motivo, práticas modernas incentivam o uso de let e const, além de uma organização clara do código, para reduzir a dependência implícita do hoisting e tornar o fluxo de execução explícito.

Em resumo, hoisting é um mecanismo estrutural do javascript que influencia como variáveis e funções existem ao longo do tempo. Entendê-lo não significa explorá-lo deliberadamente, mas saber reconhecê-lo para evitar armadilhas, interpretar corretamente o comportamento do código e escrever programas mais robustos e confiáveis.