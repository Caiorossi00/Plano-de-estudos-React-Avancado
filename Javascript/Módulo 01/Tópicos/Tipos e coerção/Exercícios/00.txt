
No primeiro exercício, o objetivo foi validar tipos de dados em tempo de execução. Como o JavaScript é uma linguagem dinamicamente tipada, o tipo de uma variável só é conhecido quando o código está rodando. Por isso, foram criadas funções como isNumber, isString e isBoolean, que utilizam principalmente o operador typeof para verificar o tipo real do valor. Alguns casos exigem cuidado extra, como NaN, que apesar de ser do tipo number, representa um valor inválido, e null, que precisa ser verificado explicitamente porque typeof null retorna "object". Essas validações evitam que valores inesperados passem despercebidos na lógica do programa.

No segundo exercício, foi abordada a diferença entre coerção implícita e comparação estrita. O operador == permite que o JavaScript converta automaticamente os tipos dos valores antes de compará-los, o que faz com que expressões como 10 == "10" ou 0 == false retornem true. Já o operador === não realiza nenhuma conversão e exige que tanto o valor quanto o tipo sejam iguais, tornando comparações como 10 === "10" ou 0 === false falsas. Entender essa diferença é essencial, pois a coerção implícita pode gerar comportamentos inesperados e bugs difíceis de identificar. Por isso, a comparação estrita é a prática recomendada em código profissional.

No terceiro exercício, o foco foi identificar tipos em tempo de execução utilizando typeof. Esse operador retorna o tipo de um valor no momento da execução, funcionando bem para a maioria dos tipos primitivos, como number, string, boolean, undefined, symbol, bigint e function. No entanto, ele possui limitações conhecidas: arrays e null são identificados como "object". Para contornar isso, a função identificarTipo trata primeiro o caso de null e depois verifica se o valor é um array usando Array.isArray, garantindo um resultado mais preciso. Esse padrão é amplamente utilizado em validações, depuração e escrita de código mais seguro em JavaScript.